\documentclass{article}
\usepackage{amsmath}
\usepackage{enumerate}
\usepackage{multicol}
\usepackage{listings}
\usepackage{graphicx}
\usepackage[margin=1in]{geometry}
\begin{document}
\section{UNIX Pipes}
\hrule
\noindent\\
\indent We will start off this guide by talking about UNIX pipes. Pipes are used by the operating system in order to transfer data from from one process to another during execution. We can imagine that a pipe acts like a file, where one process can read from the file, and the other process can write to the file. Pipes tend to follow a FIFO structure. Here are some common features of a UNIX pipe:
\begin{enumerate}
\item Pipes are limited to 10 logical blocks, with each block containing 512 bytes of data.
\item Generally, one process will read from the pipe while the other will write.
\item Data is written to one end of the pipe by a process and read from the other end of the pipe by another process.
\item There is no file pointer associated with a pipe, as there is with a normal file in UNIX.
\end{enumerate}
\indent Pipes are generally created in the kernel of the OS, and generally each process will have it's own pipe that it writes to and reads from. In other words, if \textit{Process A} is reading from a pipe that \textit{Process B} is writing to, the will also be a pipe to which \textit{Process A} can write and \textit{Process B} can read. Let's take a look at the system call to write to a file:
\begin{center} 
\begin{tabular}{c}
\begin{lstlisting}
size_t write(int file_des, const void *buffer, size_t bytes)
\end{lstlisting}
\end{tabular}
\end{center}
\indent This function will write \textit{bytes} amount of \textit{buffer} to the file descriptor given by \textit{file\_des}. It returns -1 if the call fails, or the number of bytes written otherwise. Similarly we have the \textit{read} system call:
\begin{center} 
\begin{tabular}{c}
\begin{lstlisting}
size_t read(int file_des, const void *buffer, size_t  num_bytes)
\end{lstlisting}
\end{tabular}
\end{center}
\indent The \textit{read} function will number of bytes read if successful, or -1 otherwise. We should note that we actually have two types of pipes, unnamed and named. From a programatic standpoint, we see no difference between the file descriptors for the two pipes besides the call used to make them. Unnamed pipes are used between related processes, such as parent/child, whereas named pipes are created with a directory entry and read/write permissions. Unnamed and named pipes are made with the \textit{pipe} and \textit{mknod} system calls, respectively. Let's take a look at the \textit{pipe} system call.
\begin{center} 
\begin{tabular}{c}
\begin{lstlisting}
int pipe (int file_des[2])
\end{lstlisting}
\end{tabular}
\end{center}
\indent This system call takes in an array of ints that, upon success, will contain the file descriptors for reading and writing. It will also return 0 upon success, and -1 upon failure.\\
\indent You can image that pipes could be used for I/O between processes. We have two system calls that we can use to accomplish this feat:
 \begin{center} 
\begin{tabular}{c}
\begin{lstlisting}
FILE *popen (const char *command,  const char *type)
\end{lstlisting}\\
\begin{lstlisting}
int pclose (FILE *stream)
\end{lstlisting}
\end{tabular}
\end{center}

\end{document}